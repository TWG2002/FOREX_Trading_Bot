import pandas as pd
from indicators import (
    compute_rsi,
    compute_macd,
    compute_atr,
    compute_bollinger_bands,
    compute_adx,
    detect_candlestick_patterns
)

def get_higher_timeframe_trend(client, instrument, higher_tf="M15", count=50):
    from utils import fetch_ohlc_data  # reuse your existing function
    df = fetch_ohlc_data(client, instrument, timeframe=higher_tf, count=count)
    if df.empty or len(df) < 20:
        return None
    sma = df["close"].rolling(window=20).mean().iloc[-1]
    current = df["close"].iloc[-1]
    if current > sma:
        return "up"
    elif current < sma:
        return "down"
    else:
        return "sideways"

# -------------------------------
# Current Strategy (as before)
# -------------------------------
def generate_signal(data: pd.DataFrame, htf_trend: str = None) -> str:
    """
    Current signal logic using RSI, MACD (with relaxed crossover tolerance) and (optionally) candlestick patterns.
    Returns: "BUY", "SELL", or "FLAT"
    """
    if len(data) < 2:
        return "FLAT"
    
    rsi_val = data["RSI"].iloc[-1]
    # Comment out the MACD computation and simply set the conditions to True:
    # macd_line = data["MACD"].iloc[-1]
    # macd_signal = data["MACD_signal"].iloc[-1]
    # prev_diff = data["MACD"].iloc[-2] - data["MACD_signal"].iloc[-2]
    # current_diff = data["MACD"].iloc[-1] - data["MACD_signal"].iloc[-1]
    # MACD_TOLERANCE = 2e-5
    # macd_cross_up = (prev_diff < -MACD_TOLERANCE) and (current_diff > MACD_TOLERANCE)
    # macd_cross_down = (prev_diff > MACD_TOLERANCE) and (current_diff < -MACD_TOLERANCE)
    macd_cross_up = True
    macd_cross_down = True

    bullish_pattern = data.get("BullishEngulfing", pd.Series([0])).iloc[-1] == 1
    hammer_pattern = data.get("Hammer", pd.Series([0])).iloc[-1] == 1

    signal = "FLAT"
    
    # Use a flag to decide whether to enforce the candlestick pattern filter
    USE_CANDLESTICK_FILTER = False  # For testing, you might also disable this filter

    # Check for BUY signal conditions (ignoring MACD)
    if rsi_val < 40:
        if USE_CANDLESTICK_FILTER:
            if bullish_pattern or hammer_pattern:
                if htf_trend is None or htf_trend == "up":
                    signal = "BUY"
                else:
                    print(f"Higher timeframe trend for BUY is not 'up': {htf_trend}")
        else:
            if htf_trend is None or htf_trend == "up":
                signal = "BUY"
            else:
                print(f"Higher timeframe trend for BUY is not 'up': {htf_trend}")
    # Check for SELL signal conditions (ignoring MACD)
    elif rsi_val > 60:
        if htf_trend is None or htf_trend == "down":
            signal = "SELL"
        else:
            print(f"Higher timeframe trend for SELL is not 'down': {htf_trend}")

    if signal == "FLAT":
        print("No trade signal generated by current strategy (MACD bypassed). Conditions evaluated:")
        print(f"RSI: {rsi_val} (required < 40 for BUY, > 60 for SELL)")
        print(f"Bullish Engulfing: {bullish_pattern}, Hammer: {hammer_pattern}")
        print(f"Higher timeframe trend: {htf_trend}")

    return signal

 

# ---------------------------------------------------
# New Trend Continuation Signal Logic
# ---------------------------------------------------
def generate_trend_cont_signal(data: pd.DataFrame, htf_trend: str = None) -> str:
    """
    Trend Continuation Signal Logic:
      - Confirms trend direction via a 50 EMA.
      - Looks for a pullback trigger via an RSI cross of 50.
      - Requires a MACD crossover and ADX ≥ 25.
      - For long entries, at least one bullish candlestick pattern is required.
      - If a higher timeframe trend is provided, it must agree.
    Returns: "BUY", "SELL", or "FLAT"
    """
    if len(data) < 2:
        return "FLAT"
    
    current_price = data["close"].iloc[-1]
    prev_rsi = data["RSI"].iloc[-2]
    current_rsi = data["RSI"].iloc[-1]
    adx_val = data["ADX"].iloc[-1]
    
    # Calculate 50 EMA on M1 to gauge overall trend
    ema50 = data["close"].ewm(span=50, adjust=False).mean().iloc[-1]
    
    # MACD values
    macd_line = data["MACD"].iloc[-1]
    macd_signal = data["MACD_signal"].iloc[-1]
    prev_macd_line = data["MACD"].iloc[-2]
    prev_macd_signal = data["MACD_signal"].iloc[-2]
    macd_cross_up = (prev_macd_line < prev_macd_signal) and (macd_line > macd_signal)
    macd_cross_down = (prev_macd_line > prev_macd_signal) and (macd_line < macd_signal)
    
    bullish_pattern = data.get("BullishEngulfing", pd.Series([0])).iloc[-1] == 1
    hammer_pattern = data.get("Hammer", pd.Series([0])).iloc[-1] == 1
    
    signal = "FLAT"
    
    # --- Evaluate Long Trend Continuation Conditions ---
    if current_price > ema50:
        if prev_rsi < 50 and current_rsi >= 50:
            if macd_cross_up:
                if adx_val >= 20:
                    if bullish_pattern or hammer_pattern:
                        if htf_trend is None or htf_trend == "up":
                            signal = "BUY"
                        else:
                            print(f"Higher timeframe trend for BUY is not 'up': {htf_trend}")
                    else:
                        print("No bullish candlestick pattern detected for trend continuation BUY.")
                else:
                    print(f"ADX too low for trend continuation BUY: {adx_val:.2f} (required ≥ 25)")
            else:
                print("No MACD bullish crossover for trend continuation BUY.")
        else:
            print(f"RSI did not cross above 50 for trend continuation BUY. Prev RSI: {prev_rsi:.2f}, Current RSI: {current_rsi:.2f}")
    # --- Evaluate Short Trend Continuation Conditions ---
    if current_price < ema50:
        if prev_rsi > 50 and current_rsi <= 50:
            if macd_cross_down:
                if adx_val >= 25:
                    if htf_trend is None or htf_trend == "down":
                        signal = "SELL"
                    else:
                        print(f"Higher timeframe trend for SELL is not 'down': {htf_trend}")
                else:
                    print(f"ADX too low for trend continuation SELL: {adx_val:.2f} (required ≥ 25)")
            else:
                print("No MACD bearish crossover for trend continuation SELL.")
        else:
            print(f"RSI did not cross below 50 for trend continuation SELL. Prev RSI: {prev_rsi:.2f}, Current RSI: {current_rsi:.2f}")
    
    print("Trend Continuation Signal Evaluation:")
    print(f"Current Price: {current_price:.5f}, 50 EMA: {ema50:.5f}")
    print(f"RSI: {current_rsi:.2f} (Prev: {prev_rsi:.2f}), ADX: {adx_val:.2f}")
    print(f"MACD: {macd_line:.5f} vs Signal: {macd_signal:.5f}")
    print(f"MACD cross up: {macd_cross_up}, MACD cross down: {macd_cross_down}")
    print(f"Bullish Pattern: {bullish_pattern}, Hammer: {hammer_pattern}")
    print(f"Higher Timeframe Trend: {htf_trend}")
    print(f"Trend Continuation Signal: {signal}")
    
    return signal

# ---------------------------------------------------------
# Combined Signal Function – Switches strategies based on market conditions
# ---------------------------------------------------------
def generate_combined_signal(data: pd.DataFrame, htf_trend: str = None) -> str:
    """
    Chooses between the current strategy and the trend-continuation strategy.
    Here we use the current M1 ADX value as a proxy for market strength:
      - If ADX ≥ 25, we assume the market is trending and use the trend-continuation signal.
      - Otherwise, we default to the current strategy.
    """
    if len(data) < 2:
        return "FLAT"
    
    adx_val = data["ADX"].iloc[-1]
    
    if adx_val >= 20:
        print(f"Market is trending (ADX {adx_val:.2f} ≥ 25); using trend continuation strategy.")
        return generate_trend_cont_signal(data, htf_trend)
    else:
        print(f"Market is not strongly trending (ADX {adx_val:.2f} < 25); using current strategy.")
        return generate_signal(data, htf_trend)

def apply_indicators(df: pd.DataFrame, rsi_period: int, macd_fast: int, macd_slow: int, macd_signal: int, atr_period: int):
    df["RSI"] = compute_rsi(df, rsi_period)
    macd_line, sig_line, hist = compute_macd(df, macd_fast, macd_slow, macd_signal)
    df["MACD"] = macd_line
    df["MACD_signal"] = sig_line
    df["histogram"] = hist
    df["ATR"] = compute_atr(df, atr_period)

    bb_upper, bb_mid, bb_lower = compute_bollinger_bands(df, period=20, num_std=2.0)
    df["BB_upper"] = bb_upper
    df["BB_mid"] = bb_mid
    df["BB_lower"] = bb_lower

    df["ADX"] = compute_adx(df, period=14)

    df = detect_candlestick_patterns(df)

    return df
    
